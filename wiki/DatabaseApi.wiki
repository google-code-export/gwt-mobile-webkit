#summary Quick getting started introduction to the Database API
#labels Featured,Phase-Implementation

= Introduction =

The database API ([http://gwt-mobile-webkit.googlecode.com/files/gwt-mobile-webkit-database-1.0.0.tar.gz download]) leverages the [http://www.w3.org/TR/webstorage/#sql Web Storage Database API].

Using this API you are able to store data in a SQLite database which is embedded in the browser. This is great for offline features of your application.

= Browser support =
Not every browser supports this feature, and currently there are no fallback scenario's to rely on Flash, Java or Gears plugins. We built support for the following browsers:

  # iPhone Safari (OS2.0 and higher - maybe earlier versions are supported, but are untested)
  # Desktop Safari (3.1 and higher)
  # Opera (9.5 and higher)
  # Opera Mobile (9.5 and higher - untested!)
  # Google Android (1.0 and higher - untested!)

NOTE: The Database API as specified by W3C describes two API's: an Asynchronous and a Synchronous API. Currently we only built support for the Asynchronous API, because the Synchronous API isn't supported by the current browsers that much.

= Usage =
== is API supported? ==
The following will test whether the API is supported in your browser:
{{{
if (Database.isSupported()) {
    // Interact with your database...
}
}}}

== Opening a Database ==
This line opens a database and returns a handle to that database:
{{{
Database db = Database.openDatabase("ClckCnt", "1.0", "Click Counter", 10000);
}}}

== Creating a Table ==
This code creates a new table if doesn't exist already:
{{{
db.transaction(new TransactionCallback() {
    public void onTransactionStart(SQLTransaction tx) {
        tx.executeSql("CREATE TABLE clickcount IF NOT EXISTS ("
                + "id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,"
                + "clicked INTEGER)", null);
    }
    public void onTransactionFailure(SQLError error) {
        // handle error...
    }
    public void onTransactionSuccess() {
        // Proceed when successfully committed...
    }
});
}}}

As you can see, the Database API depends heavily on callback calls. In this case, you open a database transaction by calling the 'transaction' method on the database instance, which must be provided with a callback instance to actually operate the transaction.

The transaction callback needs to implement three methods:
  # `onTransactionStart()` which executes the actual database transaction;
  # `onTransactionFailure()` which is executed when the transaction is rolled back;
  # `onTransacionSuccess()` which is executed after the transaction is successfully committed.

Within the `onTransactionStart()` method you have the `tx` parameter to execute your SQL on.

The `tx` instance provides two methods to execute SQL:
  # `executeSql(sqlStatement, arguments)`
  # `executeSql(sqlStatement, arguments, callback)`

Both methods execute the same SQL, but the second gives you a callback to handle resultsets and failures. The provided SQL must comply to the [http://sqlite.org/lang.html SQLite language]. Up to now all browser-embedded databases are of the [http://sqlite.org/ SQLite] type.

== Executing SQL ==
In order to execute SQL we need to do something like the following:
{{{
db.transaction(new TransactionCallback() {
    public void onTransactionStart(SQLTransaction tx) {
        tx.executeSql("INSERT INTO clickcount (clicked) VALUES (?)", new Object[] {new Date().getTime()});
        tx.executeSql("SELECT clicked FROM clickcount", null, new StatementCallback<ClickRow>() {
            public boolean onFailure(SQLTransaction transaction, SQLError error) {
                return false;  // don't roll back
            }
            public void onSuccess(SQLTransaction transaction, SQLResultSet<ClickRow> resultSet) {
                clickedData.clear();
                for (ClickRow row : resultSet.getRows()) {
                    clickedData.add(new Label("Clicked on " + row.getClicked()));
                }
            }
        });
    }
    public void onTransactionFailure(SQLError error) {
        // ...
    }
    public void onTransactionSuccess() {
        // ...
    }
});
}}}

The first call to `executeSql()` inserts data using a parameter list, similar to the way JDBC accepts parameters in a Statement. The parameters must be provided in an Object array, which has the same number of elements as parameters declared in the SQL statement using the `?` symbol.

The second call to `executeSql()` uses the additional callback parameter to handle the resultset. The callback mandates two methods to implement:
  # `onfailure()` is invoked if the SQL statement somehow fails. If you want to rollback the transaction, return `true` here, otherwise just return `false`. The `error` parameter provides you the failure details;
  # `onSuccess()` is invoked if the SQL was executed successfully. The `resultSet` parameter provides you the results of the query.

Both methods get the `transaction` parameter which allows you to execute additional SQL statements depending on the outcome of the executed SQL.

= Word of advice =
During testing this API it became apparent that the instance returned by by `openDatabase()` must be retained throughout the application. If you open the database multiple times during the same session, it seemed that its behavior becomes unpredictable. (perhaps I need to solve this problem in the API, but for now, be careful!)
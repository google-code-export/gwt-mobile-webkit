#summary Design discussion around the DataService as part of the Database API.
#labels API-Database,Phase-Design

= Introduction =

Interacting with the local Database is complex: it involves several levels of callbacks, and the programmer needs to deal with at least five callback methods if he wants to execute a single SQL statement.

This document explores an additional, !DataService API which should simplify the code without making it 'too simple'.

= Idea =

It would be great if we could approach a local database much like we would approach an RPC service, by means of an interface description. A !DataService would look like this:

{{{
@Connection(name = "ClckCnt", version = "1.0", description = "Click Counter", maxsize = 10000)
public interface ClickCountDataService extends DataService {

  /**
   * Makes sure that the 'clickcount' table exists in the Database.
   * Uses the Void callback to ignore any resultSet.
   */
  @SQL("CREATE TABLE IF NOT EXISTS clickcount ("
            + "id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,"
            + "clicked INTEGER)")
  void initTable(VoidCallback callback);
  
  /**
   * Records a Click value, and obtains the list of all recorded clicks.
   * Uses the List callback to handle a 'full' resultSet.
   */
  @SQL({
    "INSERT INTO clickcount (clicked) VALUES ({when.getTime()})",
    "SELECT clicked FROM clickcount"
    })
  void insertClick(Date when, ListCallback<ClickRow> callback);

  /**
   * Obtains the number of clicks recorded in the database.
   * Uses the Scalar callback to get a single value as result.
   */
  @SQL("SELECT count(*) FROM clickcount")
  void getClickCount(ScalarCallback<Integer> callback);
}
}}}

It would be used like this:

{{{
// Initialize the DataService instance:
ClickCountDataService service = GWT.create(ClickCountDataService.class);

// Make sure the clickcount table is in the database:
service.initTable(new VoidCallback() {
  public void onFailure(DataServiceException error) {
    // No success, stop the program!
  }

  public void onSuccess() {
    // The clickcount table is certainly in the database.
    // Insert a new record:
    service.insertClick(new Date(), new ListCallback<ClickRow>() {
      public void onFailure(DataServiceException error) {
        // Something went wrong!
      }

      public void onSuccess(List<ClickRow> result) {
        // Done! Now do something with the clickcount records:
        for (ClickRow row : result) {
          // ...
        }
      }
    });
  }
});
}}}

= Improvements over regular API =

The !DataService API makes several improvements over the regular Database API:
  # Separation of Concerns: The API enforces separation of the service definition itself (the !DataService interface) and the client code calling the services;
  # Simplicity: The amount of callbacks to implement a transaction are reduced from 5 to 2, while making sure all default callback behaviour is sensible. This ensures no confusion between two different `onFailure()` and `onSuccess()` methods;
  # Extensibility: If, for instance, Microsoft decides to implement the Database API in IE9, while using a completely different Database engine than SQLite, the service method might be annotated with additional compatibility annotations. GWT's Deferred Binding compiler would automatically pick the right query;


= Design issues =

Although the design looks clean and should be able to do the job, there are a few caveats:
  # The service expects the Database API to just 'be there'. How should we cope with the fact no database is available - throw an Exception at each service method, checked or unchecked? Go straight to the `onFailure()` callback?
  # The callback methods should be called after the transaction is finished. In the example above, this probably means (needs investigation) that the resultSet of the `insertClick()` call must be *copied* before the transaction ends, and then provided to the `onSuccess()` method - or, a third callback method should be provided;
  # The transaction context is totally hidden from the programmer. Each service method creates its own transaction. This is done to remove a callback level, and greatly simplifies Database programming. However, this also means that multiple service calls cannot efficiently use a single transaction context.
  # The regular !StatementCallback enables the user to rollback a transaction when something went wrong. Should the user somehow be able to specify how to handle failures, or should we just always mandate a rollback?
  # The Database API offers two transaction modes: One is read/write, the other is readonly. Should the !DataService API always, for simplicity sake, use the read/write transaction mode, or should we introspect the SQL statements to decide what mode to use?
  # How do we cope with Collections of data as *input*? For instance, adding any number of records to a table using a collection, or providing values for a SQL `IN()` expression from a Collection.

= Experimental version =

The code repository is updated with an experimental version of the !DataService API, and a new download is also available (version 1.5). Use as follows:
  # [http://code.google.com/p/gwt-mobile-webkit/downloads/list?q=label:API-Database Download] a 1.5 version of the Database API library
  # Pick up the jar file `gwt-html5-database.jar`, and/or check out sample at `samples/HelloDatabase`.

The current version implements the design issues as follows:
  # If calling `openDatabase()` fails, the callback's `onFailure()` method is invoked, rather than an Exception is thrown;
  # If the Callback expects a List resultset, the resultset is retained after the transaction (rather than copied to an ArrayList or something). This seems to work just fine on Safari;
  # The Transaction context is completely hidden from the service user;
  # Whenever a SQL failure happens, the statements are always rolled back.
  # The transactions are all in read/write mode, except if all SQL statements start with `SELECT` - in taht case, the transaction is executed in read-only mode.
  # We have *no way* yet to handle input collections. Need some thinking here!!